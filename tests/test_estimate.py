# Stacie is a STable AutoCorrelation Integral Estimator.
# Copyright (C) 2024-2025 The contributors of the Stacie Python Package.
# See the CONTRIBUTORS.md file in the project root for a full list of contributors.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
#
# --
"""Tests for ``stacie.estimate``"""

import numpy as np
import pytest

from stacie.cutoff import cv2_criterion
from stacie.estimate import fit_model_spectrum
from stacie.model import ChebyshevModel, ExpTailModel, PadeModel


@pytest.mark.parametrize(
    ("model", "pars_ref"),
    [
        (ChebyshevModel(2, even=True), [1.2, -0.05]),
        (ExpTailModel(), [1.2, 0.9, 1.1]),
        (PadeModel([0, 2], [2]), [1.2, 0.9, 1.1]),
    ],
)
def test_half_fits(model, pars_ref):
    """Perform a low-level fit for a single frequency cutoff with smooth model.

    The two half fits should coincide exactly with the full fit,
    because the smooth spectrum is generated by the model.
    """
    freqs = np.linspace(0, 0.5, 60)
    model.configure_scales(1.0, freqs, np.ones_like(freqs))
    amplitudes_ref = model.compute(1.0, freqs, pars_ref)[0]
    ndofs = np.ones(len(freqs), dtype=int)
    ndofs[1:-1] = 2
    props = fit_model_spectrum(
        1.0,
        freqs,
        amplitudes_ref,
        ndofs,
        len(freqs),
        model,
        cv2_criterion,
        np.random.default_rng(42),
        10,
    )
    assert props["pars"] == pytest.approx(pars_ref, rel=1e-2)
    assert props["pars_half1"] == pytest.approx(pars_ref, rel=1e-2)
    assert props["pars_half2"] == pytest.approx(pars_ref, rel=1e-2)


@pytest.mark.parametrize(
    ("model", "pars_ref1", "pars_ref2"),
    [
        (ChebyshevModel(2, even=True), [1.2, -0.05], [0.7, +0.1]),
        (ExpTailModel(), [1.2, 0.9, 1.1], [0.2, 1.3, 0.7]),
    ],
)
def test_half_fits_different(model, pars_ref1, pars_ref2):
    """Perform a low-level fit for a single frequency cutoff with smooth model.

    The two half fits should coincide exactly with the full fit,
    because the smooth spectrum is generated by the model.
    """
    freqs = np.linspace(0, 0.5, 60)
    model.configure_scales(1.0, freqs, np.ones_like(freqs))
    amplitudes_ref1 = model.compute(1.0, freqs, pars_ref1)[0]
    amplitudes_ref2 = model.compute(1.0, freqs, pars_ref2)[0]
    amplitudes_ref = np.concatenate([amplitudes_ref1[:30], amplitudes_ref2[30:]])
    ndofs = np.ones(len(freqs), dtype=int)
    ndofs[1:-1] = 2
    props = fit_model_spectrum(
        1.0,
        freqs,
        amplitudes_ref,
        ndofs,
        len(freqs),
        model,
        cv2_criterion,
        np.random.default_rng(42),
        10,
    )
    assert props["pars"] != pytest.approx(pars_ref1, rel=1e-2)
    assert props["pars"] != pytest.approx(pars_ref2, rel=1e-2)
    assert props["pars_half1"] == pytest.approx(pars_ref1, rel=1e-2)
    assert props["pars_half2"] == pytest.approx(pars_ref2, rel=1e-2)
