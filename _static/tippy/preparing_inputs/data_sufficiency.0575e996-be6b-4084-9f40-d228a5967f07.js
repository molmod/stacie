selector_to_html = {"a[href=\"https://en.wikipedia.org/wiki/Spectral_leakage\"]": "<p>The Fourier transform of a function of time, s(t), is a complex-valued function of frequency, S(f), often referred to as a frequency spectrum. Any linear time-invariant operation on s(t) produces a new spectrum of the form H(f)\u2022S(f), which changes the relative magnitudes and/or angles (phase) of the non-zero values of S(f). Any other type of operation creates new frequency components that may be referred to as <b>spectral leakage</b> in the broadest sense. Sampling, for instance, produces leakage, which we call <i>aliases</i> of the original spectral component. For Fourier transform purposes, sampling is modeled as a product between s(t) and a Dirac comb function. The spectrum of a product is the convolution between S(f) and another function, which inevitably creates the new frequency components. But the term 'leakage' usually refers to the effect of <i>windowing</i>, which is the product of s(t) with a different kind of function, the window function. Window functions happen to have finite duration, but that is not necessary to create leakage. Multiplication by a time-variant function is sufficient.</p>", "a[href^=\"https://en.wikipedia.org/wiki/Spectral_leakage#\"]": "<p>The Fourier transform of a function of time, s(t), is a complex-valued function of frequency, S(f), often referred to as a frequency spectrum. Any linear time-invariant operation on s(t) produces a new spectrum of the form H(f)\u2022S(f), which changes the relative magnitudes and/or angles (phase) of the non-zero values of S(f). Any other type of operation creates new frequency components that may be referred to as <b>spectral leakage</b> in the broadest sense. Sampling, for instance, produces leakage, which we call <i>aliases</i> of the original spectral component. For Fourier transform purposes, sampling is modeled as a product between s(t) and a Dirac comb function. The spectrum of a product is the convolution between S(f) and another function, which inevitably creates the new frequency components. But the term 'leakage' usually refers to the effect of <i>windowing</i>, which is the product of s(t) with a different kind of function, the window function. Window functions happen to have finite duration, but that is not necessary to create leakage. Multiplication by a time-variant function is sufficient.</p>", "a[href=\"#step-2-test-the-sufficiency-of-the-number-of-steps-and-increase-if-necessary\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Step 2: Test the Sufficiency of the Number of Steps and Increase if Necessary<a class=\"headerlink\" href=\"#step-2-test-the-sufficiency-of-the-number-of-steps-and-increase-if-necessary\" title=\"Link to this heading\">\u00b6</a></h2><p>There is no simple way to know <em>a priori</em> the required number of steps in the input sequences.\nHence, we recommend first generating inputs with about <span class=\"math notranslate nohighlight\">\\(400\\,P\\)</span> steps,\nwhere <span class=\"math notranslate nohighlight\">\\(P\\)</span> is the number of model parameters, and analyzing these inputs with STACIE.\nWith this choice, the first <span class=\"math notranslate nohighlight\">\\(20 P\\)</span> points that are ideally used for fitting\nwill be a factor <span class=\"math notranslate nohighlight\">\\(10\\)</span> below the Nyquist frequency,\nwhich is a minimal first attempt to identify the low-frequency part of the spectrum.\nUsing these data as inputs, you will obtain a first estimate\nof the autocorrelation integral and its relative error.\nIf the relative error is larger than the desired value,\nyou can extend the input sequences with additional steps and repeat the analysis.</p><p>Note that for some applications, <span class=\"math notranslate nohighlight\">\\(400\\,P\\)</span> steps may be far too short,\nmeaning that you will need to extend your inputs a few times\nbefore you get a clear picture of the relative error.\nIt is not uncommon to run into problems with storage quota in this scenario.\nTo reduce the storage requirements, <a class=\"reference internal\" href=\"block_averages.html\"><span class=\"std std-doc\">block averages</span></a> can be helpful.</p>", "a[href=\"../theory/statistics.html\"]": "<h1 class=\"tippy-header\" style=\"margin-top: 0;\">Parameter Estimation<a class=\"headerlink\" href=\"#parameter-estimation\" title=\"Link to this heading\">\u00b6</a></h1><p>Before discussing how to fit a model to spectral data,\nwe first review the statistics of the sampling <a class=\"reference internal\" href=\"../glossary.html#term-PSD\"><span class=\"xref std std-term\">PSD</span></a>.\nGiven these statistical properties,\nwe can derive the likelihood that certain model parameters explain the observed PSD.</p>", "a[href=\"../properties/index.html\"]": "<h1 class=\"tippy-header\" style=\"margin-top: 0;\">Properties Derived from the Autocorrelation Function<a class=\"headerlink\" href=\"#properties-derived-from-the-autocorrelation-function\" title=\"Link to this heading\">\u00b6</a></h1><p>This section outlines the statistical and physical quantities\nthat can be computed as the integral of an autocorrelation function.\nFor each property, a code skeleton is provided as a starting point for your calculations.\nAll skeletons assume that you can load the relevant input data into NumPy arrays.</p><p>First, we discuss a few properties that may be relevant to multiple scientific disciplines:</p>", "a[href=\"#step-1-guesstimate-the-number-of-independent-sequences\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Step 1: Guesstimate the Number of Independent Sequences<a class=\"headerlink\" href=\"#step-1-guesstimate-the-number-of-independent-sequences\" title=\"Link to this heading\">\u00b6</a></h2><p>Because the amplitudes of the (rescaled) sampling PSD are Gamma-distributed,\none can show that the relative error of the PSD (mean divided by the standard deviation)\nis given by:</p>", "a[href=\"#how-to-prepare-sufficient-inputs-for-stacie\"]": "<h1 class=\"tippy-header\" style=\"margin-top: 0;\">How to Prepare Sufficient Inputs for STACIE?<a class=\"headerlink\" href=\"#how-to-prepare-sufficient-inputs-for-stacie\" title=\"Link to this heading\">\u00b6</a></h1><p>This section explains how to achieve a desired relative error <span class=\"math notranslate nohighlight\">\\(\\epsilon_\\text{rel}\\)</span>\nof the autocorrelation integral estimate, <span class=\"math notranslate nohighlight\">\\(\\hat{\\mathcal{I}}\\)</span>.\nThe preparation of sufficient inputs consists of two steps:</p>", "a[href=\"../theory/model.html\"]": "<h1 class=\"tippy-header\" style=\"margin-top: 0;\">Model Spectrum<a class=\"headerlink\" href=\"#model-spectrum\" title=\"Link to this heading\">\u00b6</a></h1><p>STACIE supports three models for fitting the low-frequency part of the power spectrum.\nIn both models, the value at zero frequency corresponds to the autocorrelation integral.</p>", "a[href=\"block_averages.html\"]": "<h1 class=\"tippy-header\" style=\"margin-top: 0;\">Reducing Storage Requirements with Block Averages<a class=\"headerlink\" href=\"#reducing-storage-requirements-with-block-averages\" title=\"Link to this heading\">\u00b6</a></h1><p>When computer simulations generate time-dependent data,\nthey often use a discretization of the time axis with a resolution (much) higher\nthan needed for computing the autocorrelation integral with STACIE.\nStoring (and processing) all these data may require excessive resources.\nTo reduce the amount of data, we recommend taking block averages.\nThese block averages form a new time series with a time step equal to the block size\nmultiplied by the original time step.\nThey reduce storage requirements by a factor equal to the block size.\nIf the program generating the sequences does not support block averages,\nyou can use <a class=\"reference internal\" href=\"../apidocs/stacie.utils.html#stacie.utils.block_average\" title=\"stacie.utils.block_average\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">stacie.utils.block_average()</span></code></a>.</p><p>If the blocks are sufficiently small compared to the decay rate of the autocorrelation function,\nSTACIE will produce virtually the same results.\nThe effect of block averages can be understood by inserting them into the discrete power spectrum,\nusing STACIE\u2019s normalization convention to obtain the proper zero-frequency limit.\nLet <span class=\"math notranslate nohighlight\">\\(\\hat{a}_\\ell\\)</span> be the <span class=\"math notranslate nohighlight\">\\(\\ell\\)</span>\u2019th block average of <span class=\"math notranslate nohighlight\">\\(L\\)</span> blocks with block size <span class=\"math notranslate nohighlight\">\\(B\\)</span>.\nWe can start from the power spectrum of the original sequence, <span class=\"math notranslate nohighlight\">\\(\\hat{x}_n\\)</span>,\nand then introduce approximations to rewrite it in terms of the block averages:</p>"}
skip_classes = ["headerlink", "sd-stretched-link"]

window.onload = function () {
    for (const [select, tip_html] of Object.entries(selector_to_html)) {
        const links = document.querySelectorAll(` ${select}`);
        for (const link of links) {
            if (skip_classes.some(c => link.classList.contains(c))) {
                continue;
            }

            tippy(link, {
                content: tip_html,
                allowHTML: true,
                arrow: true,
                placement: 'auto-start', maxWidth: 500, interactive: false,

            });
        };
    };
    console.log("tippy tips loaded!");
};
