selector_to_html = {"a[href=\"https://en.wikipedia.org/wiki/Nyquist%E2%80%93Shannon_sampling_theorem\"]": "<img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/f/f7/Bandlimited.svg/330px-Bandlimited.svg.png\" alt=\"Wikipedia thumbnail\" style=\"float:left; margin-right:10px;\"><p>The <b>Nyquist\u2013Shannon sampling theorem</b> is an essential principle for digital signal processing linking the frequency range of a signal and the sample rate required to avoid a type of distortion called aliasing. The theorem states that the sample rate must be at least twice the bandwidth of the signal to avoid aliasing. In practice, it is used to select band-limiting filters to keep aliasing below an acceptable amount when an analog signal is sampled or when sample rates are changed within a digital signal processing function.</p>", "a[href^=\"https://en.wikipedia.org/wiki/Nyquist%E2%80%93Shannon_sampling_theorem#\"]": "<img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/f/f7/Bandlimited.svg/330px-Bandlimited.svg.png\" alt=\"Wikipedia thumbnail\" style=\"float:left; margin-right:10px;\"><p>The <b>Nyquist\u2013Shannon sampling theorem</b> is an essential principle for digital signal processing linking the frequency range of a signal and the sample rate required to avoid a type of distortion called aliasing. The theorem states that the sample rate must be at least twice the bandwidth of the signal to avoid aliasing. In practice, it is used to select band-limiting filters to keep aliasing below an acceptable amount when an analog signal is sampled or when sample rates are changed within a digital signal processing function.</p>", "a[href=\"#nernst-einstein-approximation\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Nernst-Einstein Approximation<a class=\"headerlink\" href=\"#nernst-einstein-approximation\" title=\"Link to this heading\">\u00b6</a></h2><p>The electrical conductivity is related to the (correlated) diffusion of the charge carriers.\nWhen correlations between the ions are neglected, one obtains the Nernst-Einstein approximation\nof the conductivity in terms of the self-diffusion coefficients of the ions.\nWe include the derivation here because a consistent treatment of the pre-factors\ncan be challenging.\n(Literature references are not always consistent due to differences in notation.)\nOur derivation is general, i.e., for an arbitrary number of different <em>types</em>\nof charge carriers, which are not restricted to monovalent ions.</p><p>First, insert the expression for the charge current into the conductivity\nand then bring the sums out of the integral:</p>", "a[href=\"#ionic-electrical-conductivity\"]": "<h1 class=\"tippy-header\" style=\"margin-top: 0;\">Ionic Electrical Conductivity<a class=\"headerlink\" href=\"#ionic-electrical-conductivity\" title=\"Link to this heading\">\u00b6</a></h1><p>The ionic electrical conductivity of a system is related to the autocorrelation\nof the charge current as follows:</p>", "a[href=\"#how-to-compute-with-stacie\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">How to Compute with STACIE?<a class=\"headerlink\" href=\"#how-to-compute-with-stacie\" title=\"Link to this heading\">\u00b6</a></h2><p>It is assumed that you can load the time-dependent ion velocity components\ninto a NumPy array <code class=\"docutils literal notranslate\"><span class=\"pre\">ionvels</span></code>.\nIn the example below, this is a three-index array,\nwhere the first index is for the ion, the second for the Cartesian component,\nand the last for the time step.\nTo compute the charge current, you need to put the charges of the ions\nin an array <code class=\"docutils literal notranslate\"><span class=\"pre\">charges</span></code>.\nYou also need to store the cell volume, temperature,\nBoltzmann constant, and time step in Python variables,\nall in consistent units.\nWith these requirements, the ionic electrical conductivity can be computed as follows:</p>", "a[href=\"../examples/molten_salt.html\"]": "<h1 class=\"tippy-header\" style=\"margin-top: 0;\">Ionic Electrical Conductivity of Molten Sodium Chloride at 1100 K (OpenMM)<a class=\"headerlink\" href=\"#ionic-electrical-conductivity-of-molten-sodium-chloride-at-1100-k-openmm\" title=\"Link to this heading\">\u00b6</a></h1><p>This notebook shows how to post-process trajectories from OpenMM simulations\nto calculate the ionic electrical conductivity.\nThe OpenMM trajectories are converted to NPZ files within the Jupyter Notebooks of the simulation,\nmaking the approach here easily adaptable to other codes or physical systems.\nAll OpenMM simulation notebooks can be found in the directory <code class=\"docutils literal notranslate\"><span class=\"pre\">docs/data/openmm_salt</span></code>\nin STACIE\u2019s source repository.\nThe required theoretical background is explained the\n<a class=\"reference internal\" href=\"../properties/electrical_conductivity.html\"><span class=\"std std-doc\">Ionic Electrical Conductivity</span></a> section.</p><p>The MD simulations are performed using the Born-Huggins-Mayer-Tosi-Fumi potential,\nwhich is a popular choice for molten salts. <span id=\"id1\">[<a class=\"reference internal\" href=\"../references.html#id49\" title=\"M.P. Tosi and F.G. Fumi. Ionic sizes and born repulsive parameters in the nacl-type alkali halides\u2014ii: the generalized huggins-mayer form. J. Phys. Chem. Solids, 25(1):45-52, 1964. doi:10.1016/0022-3697(64)90160-X.\">TF64</a>]</span>\nThis potential does not use mixing rules and it is not natively implemented in OpenMM,\nbut it can be incorporated using the <code class=\"docutils literal notranslate\"><span class=\"pre\">CustomNonbondedForce</span></code> and some creativity,\nsee <code class=\"docutils literal notranslate\"><span class=\"pre\">docs/data/openmm_salt/bhmft.py</span></code> in the Git repository.\nThe molten salt was simulated with a 3D periodic box of 1728 ions (864 Na<span class=\"math notranslate nohighlight\">\\(^+\\)</span> and 864 Cl<span class=\"math notranslate nohighlight\">\\(^-\\)</span>).\nThe time step in all simulations was 5 fs.</p>", "a[href=\"../preparing_inputs/block_averages.html\"]": "<h1 class=\"tippy-header\" style=\"margin-top: 0;\">Reducing Storage Requirements with Block Averages<a class=\"headerlink\" href=\"#reducing-storage-requirements-with-block-averages\" title=\"Link to this heading\">\u00b6</a></h1><p>When computer simulations generate time-dependent data,\nthey often use a discretization of the time axis with a resolution (much) higher\nthan needed for computing the autocorrelation integral with STACIE.\nStoring (and processing) all these data may require excessive resources.\nTo reduce the amount of data, we recommend taking block averages.\nThese block averages form a new time series with a time step equal to the block size\nmultiplied by the original time step.\nThey reduce storage requirements by a factor equal to the block size.\nIf the program generating the sequences does not support block averages,\nyou can use <a class=\"reference internal\" href=\"../apidocs/stacie.utils.html#stacie.utils.block_average\" title=\"stacie.utils.block_average\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">stacie.utils.block_average()</span></code></a>.</p><p>If the blocks are sufficiently small compared to the decay rate of the autocorrelation function,\nSTACIE will produce virtually the same results.\nThe effect of block averages can be understood by inserting them into the discrete power spectrum,\nusing STACIE\u2019s normalization convention to obtain the proper zero-frequency limit.\nLet <span class=\"math notranslate nohighlight\">\\(\\hat{a}_\\ell\\)</span> be the <span class=\"math notranslate nohighlight\">\\(\\ell\\)</span>\u2019th block average of <span class=\"math notranslate nohighlight\">\\(L\\)</span> blocks with block size <span class=\"math notranslate nohighlight\">\\(B\\)</span>.\nWe can start from the power spectrum of the original sequence, <span class=\"math notranslate nohighlight\">\\(\\hat{x}_n\\)</span>,\nand then introduce approximations to rewrite it in terms of the block averages:</p>"}
skip_classes = ["headerlink", "sd-stretched-link"]

window.onload = function () {
    for (const [select, tip_html] of Object.entries(selector_to_html)) {
        const links = document.querySelectorAll(` ${select}`);
        for (const link of links) {
            if (skip_classes.some(c => link.classList.contains(c))) {
                continue;
            }

            tippy(link, {
                content: tip_html,
                allowHTML: true,
                arrow: true,
                placement: 'auto-start', maxWidth: 500, interactive: false,

            });
        };
    };
    console.log("tippy tips loaded!");
};
