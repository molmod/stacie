selector_to_html = {"a[href=\"error_estimates.html\"]": "<h1 class=\"tippy-header\" style=\"margin-top: 0;\">Uncertainty of the Mean of Time-Correlated Data<a class=\"headerlink\" href=\"#uncertainty-of-the-mean-of-time-correlated-data\" title=\"Link to this heading\">\u00b6</a></h1><p>When data exhibits time correlations,\nthe error of the average cannot be computed by assuming that all data are statistically independent.\nBecause of time correlations, there are fewer independent values than the number of elements in the data.</p><p>Quantifying the <a class=\"reference internal\" href=\"../glossary.html#term-Uncertainty\"><span class=\"xref std std-term\">uncertainty</span></a> of averages over time-correlated data is discussed\nin several textbooks, e.g.,\nAppendix D of \u201cUnderstanding Molecular Simulation\u201d\nby Frenkel and Smit <span id=\"id1\">[<a class=\"reference internal\" href=\"../references.html#id19\" title=\"Daan Frenkel and Berend Smit. Understanding Molecular Simulation. Elsevier, 2002. ISBN 9780122673511. doi:10.1016/b978-0-12-267351-1.x5000-7.\">FS02</a>]</span>,\nor Section 8.4 in the book \u201cComputer Simulation of Liquids\u201d (second edition)\nby Allen and Tildesley <span id=\"id2\">[<a class=\"reference internal\" href=\"../references.html#id31\" title=\"Michael P. Allen and Dominic J. Tildesley. Computer Simulation of Liquids (second edition). Oxford University Press, 2017. ISBN 9780198803195. doi:10.1093/oso/9780198803195.001.0001.\">AT17</a>]</span>.</p>", "a[href=\"../theory/model.html#section-pade-target\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">2. Pade Model<a class=\"headerlink\" href=\"#pade-model\" title=\"Link to this heading\">\u00b6</a></h2><p>The <a class=\"reference internal\" href=\"../apidocs/stacie.model.html#stacie.model.PadeModel\" title=\"stacie.model.PadeModel\"><span class=\"xref myst py py-class\">PadeModel</span></a> is defined as:</p>", "a[href=\"../theory/overview.html\"]": "<h1 class=\"tippy-header\" style=\"margin-top: 0;\">STACIE Algorithm Overview<a class=\"headerlink\" href=\"#stacie-algorithm-overview\" title=\"Link to this heading\">\u00b6</a></h1><p>The goal of STACIE is to estimate the integral of the <a class=\"reference internal\" href=\"../glossary.html#term-ACF\"><span class=\"xref std std-term\">ACF</span></a>\nof a physical, continuous, time-dependent function with an infinite domain.\nIn practice, due to inherently finite computational resources, however,\nwe resort to discrete and finite time-dependent sequences.\nWe first formulate STACIE\u2019s goal in the continuous case\nand then reformulate it in the discrete case.</p>", "a[href=\"#definitions\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Definitions<a class=\"headerlink\" href=\"#definitions\" title=\"Link to this heading\">\u00b6</a></h2><p>There are two definitions of the autocorrelation time <span id=\"id1\">[<a class=\"reference internal\" href=\"../references.html#id18\" title=\"A. Sokal. Monte Carlo Methods in Statistical Mechanics: Foundations and New Algorithms, pages 131\u2013192. Springer US, Boston, MA, 1997. doi:10.1007/978-1-4899-0319-8_6.\">Sok97</a>]</span>:</p>", "a[href=\"#how-to-compute-with-stacie\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">How to Compute with STACIE?<a class=\"headerlink\" href=\"#how-to-compute-with-stacie\" title=\"Link to this heading\">\u00b6</a></h2><p>It is assumed that you can load one or (ideally) more\ntime-dependent sequences of equal length into a 2D NumPy array <code class=\"docutils literal notranslate\"><span class=\"pre\">sequences</span></code>.\nEach row in this array is a sequence, and the columns correspond to time steps.\nYou also need to store the time step in a Python variable.\n(If your data does not have a time step, just omit it from the code below.)</p><p>With these data, the autocorrelation times are computed as follows:</p>", "a[href=\"../preparing_inputs/block_averages.html\"]": "<h1 class=\"tippy-header\" style=\"margin-top: 0;\">Reducing Storage Requirements with Block Averages<a class=\"headerlink\" href=\"#reducing-storage-requirements-with-block-averages\" title=\"Link to this heading\">\u00b6</a></h1><p>When computer simulations generate time-dependent data,\nthey often use a discretization of the time axis with a resolution (much) higher\nthan needed for computing the autocorrelation integral with STACIE.\nStoring (and processing) all these data may require excessive resources.\nTo reduce the amount of data, we recommend taking block averages.\nThese block averages form a new time series with a time step equal to the block size\nmultiplied by the original time step.\nThey reduce storage requirements by a factor equal to the block size.\nIf the program generating the sequences does not support block averages,\nyou can use <a class=\"reference internal\" href=\"../apidocs/stacie.utils.html#stacie.utils.block_average\" title=\"stacie.utils.block_average\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">stacie.utils.block_average()</span></code></a>.</p><p>If the blocks are sufficiently small compared to the decay rate of the autocorrelation function,\nSTACIE will produce virtually the same results.\nThe effect of block averages can be understood by inserting them into the discrete power spectrum,\nusing STACIE\u2019s normalization convention to obtain the proper zero-frequency limit.\nLet <span class=\"math notranslate nohighlight\">\\(\\hat{a}_\\ell\\)</span> be the <span class=\"math notranslate nohighlight\">\\(\\ell\\)</span>\u2019th block average of <span class=\"math notranslate nohighlight\">\\(L\\)</span> blocks with block size <span class=\"math notranslate nohighlight\">\\(B\\)</span>.\nWe can start from the power spectrum of the original sequence, <span class=\"math notranslate nohighlight\">\\(\\hat{x}_n\\)</span>,\nand then introduce approximations to rewrite it in terms of the block averages:</p>", "a[href=\"../preparing_inputs/data_sufficiency.html\"]": "<h1 class=\"tippy-header\" style=\"margin-top: 0;\">How to Prepare Sufficient Inputs for STACIE?<a class=\"headerlink\" href=\"#how-to-prepare-sufficient-inputs-for-stacie\" title=\"Link to this heading\">\u00b6</a></h1><p>This section explains how to achieve a desired relative error <span class=\"math notranslate nohighlight\">\\(\\epsilon_\\text{rel}\\)</span>\nof the autocorrelation integral estimate, <span class=\"math notranslate nohighlight\">\\(\\hat{\\mathcal{I}}\\)</span>.\nThe preparation of sufficient inputs consists of two steps:</p>", "a[href=\"../apidocs/stacie.spectrum.html#stacie.spectrum.compute_spectrum\"]": "<dt class=\"sig sig-object py\" id=\"stacie.spectrum.compute_spectrum\">\n<span class=\"sig-name descname\"><span class=\"pre\">compute_spectrum</span></span><span class=\"sig-paren\">(</span><em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">sequences</span></span></em>, <em class=\"sig-param\"><span class=\"keyword-only-separator o\"><abbr title=\"Keyword-only parameters separator (PEP 3102)\"><span class=\"pre\">*</span></abbr></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">prefactors</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">1.0</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">timestep</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">1</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">include_zero_freq</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">True</span></span></em><span class=\"sig-paren\">)</span><a class=\"reference internal\" href=\"../_modules/stacie/spectrum.html#compute_spectrum\"><span class=\"viewcode-link\"><span class=\"pre\">[source]</span></span></a></dt><dd><p>Compute a spectrum and return it as a <a class=\"reference internal\" href=\"#stacie.spectrum.Spectrum\" title=\"stacie.spectrum.Spectrum\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">Spectrum</span></code></a> object.</p><p>The spectrum amplitudes are computed as follows:</p><p>where:</p><p>The sum over <span class=\"math notranslate nohighlight\">\\(m\\)</span> simply averages spectra obtained from different sequences.\nThe factor <span class=\"math notranslate nohighlight\">\\(F_m h/ 2 N\\)</span> normalizes the spectrum so that its zero-frequency limit\nis an estimate of the autocorrelation integral.</p></dd>", "a[href=\"#integrated-and-exponential-autocorrelation-time\"]": "<h1 class=\"tippy-header\" style=\"margin-top: 0;\">Integrated and Exponential Autocorrelation Time<a class=\"headerlink\" href=\"#integrated-and-exponential-autocorrelation-time\" title=\"Link to this heading\">\u00b6</a></h1><h2>Definitions<a class=\"headerlink\" href=\"#definitions\" title=\"Link to this heading\">\u00b6</a></h2><p>There are two definitions of the autocorrelation time <span id=\"id1\">[<a class=\"reference internal\" href=\"../references.html#id18\" title=\"A. Sokal. Monte Carlo Methods in Statistical Mechanics: Foundations and New Algorithms, pages 131\u2013192. Springer US, Boston, MA, 1997. doi:10.1007/978-1-4899-0319-8_6.\">Sok97</a>]</span>:</p>", "a[href=\"../theory/model.html\"]": "<h1 class=\"tippy-header\" style=\"margin-top: 0;\">Model Spectrum<a class=\"headerlink\" href=\"#model-spectrum\" title=\"Link to this heading\">\u00b6</a></h1><p>STACIE supports three models for fitting the low-frequency part of the power spectrum.\nIn all models, the value at zero frequency corresponds to the autocorrelation integral.</p>", "a[href=\"../apidocs/stacie.utils.html#stacie.utils.split\"]": "<dt class=\"sig sig-object py\" id=\"stacie.utils.split\">\n<span class=\"sig-name descname\"><span class=\"pre\">split</span></span><span class=\"sig-paren\">(</span><em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">sequences</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">nsplit</span></span></em><span class=\"sig-paren\">)</span><a class=\"reference internal\" href=\"../_modules/stacie/utils.html#split\"><span class=\"viewcode-link\"><span class=\"pre\">[source]</span></span></a></dt><dd><p>Split input sequences into shorter parts of equal length.</p><p>This reduces the resolution of the frequency axis of the spectrum,\nwhich may be useful when the sequence length is much longer than the exponential\nautocorrelation time.</p></dd>", "a[href=\"../examples/surface_diffusion.html\"]": "<h1 class=\"tippy-header\" style=\"margin-top: 0;\">Diffusion on a Surface with Newtonian Dynamics<a class=\"headerlink\" href=\"#diffusion-on-a-surface-with-newtonian-dynamics\" title=\"Link to this heading\">\u00b6</a></h1><p>This example shows how to compute the diffusion coefficient\nof a particle adsorbed on a crystal surface.\nFor simplicity, the motion of the adsorbed particle is described\nby Newton\u2019s equations (without thermostat), i.e. in the <a class=\"reference internal\" href=\"../glossary.html#term-NVE\"><span class=\"xref std std-term\">NVE</span></a> ensemble,\nand the particle can only move in two dimensions.</p><p>This is a completely self-contained example that generates the input sequences\n(with numerical integration) and then analyzes them with STACIE.\nUnless otherwise noted, atomic units are used.</p>", "a[href=\"#which-definition-should-i-use\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Which Definition Should I Use?<a class=\"headerlink\" href=\"#which-definition-should-i-use\" title=\"Link to this heading\">\u00b6</a></h2><p>There is no right or wrong.\nBoth definitions are useful and relevant for different applications.</p>"}
skip_classes = ["headerlink", "sd-stretched-link"]

window.onload = function () {
    for (const [select, tip_html] of Object.entries(selector_to_html)) {
        const links = document.querySelectorAll(` ${select}`);
        for (const link of links) {
            if (skip_classes.some(c => link.classList.contains(c))) {
                continue;
            }

            tippy(link, {
                content: tip_html,
                allowHTML: true,
                arrow: true,
                placement: 'auto-start', maxWidth: 500, interactive: false,

            });
        };
    };
    console.log("tippy tips loaded!");
};
