selector_to_html = {"a[href=\"https://en.wikipedia.org/wiki/Chaos_theory\"]": "<img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/5/5b/Lorenz_attractor_yb.svg/330px-Lorenz_attractor_yb.svg.png\" alt=\"Wikipedia thumbnail\" style=\"float:left; margin-right:10px;\"><p><b>Chaos theory</b> is an interdisciplinary area of scientific study and branch of mathematics. It focuses on underlying patterns and deterministic laws of dynamical systems that are highly sensitive to initial conditions. These were once thought to have completely random states of disorder and irregularities. Chaos theory states that within the apparent randomness of chaotic complex systems, there are underlying patterns, interconnection, constant feedback loops, repetition, self-similarity, fractals and self-organization. The butterfly effect, an underlying principle of chaos, describes how a small change in one state of a deterministic nonlinear system can result in large differences in a later state. A metaphor for this behavior is that a butterfly flapping its wings in Brazil can cause or prevent a tornado in Texas.</p>", "a[href^=\"https://en.wikipedia.org/wiki/Chaos_theory#\"]": "<img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/5/5b/Lorenz_attractor_yb.svg/330px-Lorenz_attractor_yb.svg.png\" alt=\"Wikipedia thumbnail\" style=\"float:left; margin-right:10px;\"><p><b>Chaos theory</b> is an interdisciplinary area of scientific study and branch of mathematics. It focuses on underlying patterns and deterministic laws of dynamical systems that are highly sensitive to initial conditions. These were once thought to have completely random states of disorder and irregularities. Chaos theory states that within the apparent randomness of chaotic complex systems, there are underlying patterns, interconnection, constant feedback loops, repetition, self-similarity, fractals and self-organization. The butterfly effect, an underlying principle of chaos, describes how a small change in one state of a deterministic nonlinear system can result in large differences in a later state. A metaphor for this behavior is that a butterfly flapping its wings in Brazil can cause or prevent a tornado in Texas.</p>", "a[href=\"https://en.wikipedia.org/wiki/Verlet_integration\"]": "<p><b>Verlet integration</b> is a numerical method used to integrate Newton's equations of motion. It is frequently used to calculate trajectories of particles in molecular dynamics simulations and computer graphics. The algorithm was first used in 1791 by Jean Baptiste Delambre and has been rediscovered many times since then, most recently by Loup Verlet in the 1960s for use in molecular dynamics. It was also used by P. H. Cowell and A. C. C. Crommelin in 1909 to compute the orbit of Halley's Comet, and by Carl St\u00f8rmer in 1907 to study the trajectories of electrical particles in a magnetic field .\nThe Verlet integrator provides good numerical stability, as well as other properties that are important in physical systems such as time reversibility and preservation of the symplectic form on phase space, at no significant additional computational cost over the simple Euler method.</p>", "a[href^=\"https://en.wikipedia.org/wiki/Verlet_integration#\"]": "<p><b>Verlet integration</b> is a numerical method used to integrate Newton's equations of motion. It is frequently used to calculate trajectories of particles in molecular dynamics simulations and computer graphics. The algorithm was first used in 1791 by Jean Baptiste Delambre and has been rediscovered many times since then, most recently by Loup Verlet in the 1960s for use in molecular dynamics. It was also used by P. H. Cowell and A. C. C. Crommelin in 1909 to compute the orbit of Halley's Comet, and by Carl St\u00f8rmer in 1907 to study the trajectories of electrical particles in a magnetic field .\nThe Verlet integrator provides good numerical stability, as well as other properties that are important in physical systems such as time reversibility and preservation of the symplectic form on phase space, at no significant additional computational cost over the simple Euler method.</p>", "a[href=\"#diffusion-on-a-surface-with-newtonian-dynamics\"]": "<h1 class=\"tippy-header\" style=\"margin-top: 0;\">Diffusion on a Surface with Newtonian Dynamics<a class=\"headerlink\" href=\"#diffusion-on-a-surface-with-newtonian-dynamics\" title=\"Link to this heading\">\u00b6</a></h1><p>This example shows how to compute the diffusion coefficient\nof a particle adsorbed on a crystal surface.\nFor simplicity, the motion of the adsorbed particle is described\nby Newton\u2019s equations (without thermostat), i.e. in the <a class=\"reference internal\" href=\"../glossary.html#term-NVE\"><span class=\"xref std std-term\">NVE</span></a> ensemble,\nand the particle can only move in two dimensions.</p><p>This is a completely self-contained example that generates the input sequences\n(with numerical integration) and then analyzes them with STACIE.\nUnless otherwise noted, atomic units are used.</p>", "a[href=\"#surface-diffusion-without-block-averages\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Surface diffusion without block averages<a class=\"headerlink\" href=\"#surface-diffusion-without-block-averages\" title=\"Link to this heading\">\u00b6</a></h2><p>This section considers 100 independent particles whose initial velocities\nhave the same magnitude but whose directions are random.\nThe time-dependent particle velocities are used as inputs for STACIE\nto compute the diffusion coefficient.</p>", "a[href=\"#newtonian-dynamics\"]": "<h3 class=\"tippy-header\" style=\"margin-top: 0;\">Newtonian Dynamics<a class=\"headerlink\" href=\"#newtonian-dynamics\" title=\"Link to this heading\">\u00b6</a></h3><p>The following code cell implements a vectorized\n<a class=\"reference external\" href=\"https://en.wikipedia.org/wiki/Verlet_integration#Velocity_Verlet\">Velocity Verlet integrator</a>,\nwhich can integrate multiple independent trajectories at the same time.\nSome parameters, like mass and time step are fixed as global constants.\nThe mass is that of an Argon atom converted to atomic units.\nThe timestep is five femtosecond converted to atomic units.</p>", "a[href=\"#data-generation\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Data Generation<a class=\"headerlink\" href=\"#data-generation\" title=\"Link to this heading\">\u00b6</a></h2><h3>Potential energy surface<a class=\"headerlink\" href=\"#potential-energy-surface\" title=\"Link to this heading\">\u00b6</a></h3><p>The first cell below defines the potential energy of a particle on a surface,\nas well as the force that the surface exerts on the particle.\nThe potential energy model is a superposition of cosine functions:</p>", "a[href=\"../glossary.html#term-NVE\"]": "<dt id=\"term-NVE\">NVE</dt><dd><p>Microcanonical ensemble.\nA statistical ensemble that represents a closed system\nwith fixed energy (E), volume (V), and number of particles (N).</p></dd>", "a[href=\"#regression-tests\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Regression Tests<a class=\"headerlink\" href=\"#regression-tests\" title=\"Link to this heading\">\u00b6</a></h2><p>If you are experimenting with this notebook, you can ignore any exceptions below.\nThe tests are only meant to pass for the notebook in its original form.</p>", "a[href=\"#demonstration-of-deterministic-choas\"]": "<h3 class=\"tippy-header\" style=\"margin-top: 0;\">Demonstration of Deterministic Choas<a class=\"headerlink\" href=\"#demonstration-of-deterministic-choas\" title=\"Link to this heading\">\u00b6</a></h3><p>Newtonian dynamics is deterministic,\nbut has chaotic solutions for many systems.\nThe particle on a surface in this notebook is no exception.\nThe following cell shows two trajectories\nfor nearly identical initial conditions,\nbut they slowly drift apart over time.\nAfter sufficient time,\nany information about their nearly identical initial conditions is lost.</p>", "a[href=\"#library-imports-and-matplotlib-configuration\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Library Imports and Matplotlib Configuration<a class=\"headerlink\" href=\"#library-imports-and-matplotlib-configuration\" title=\"Link to this heading\">\u00b6</a></h2>", "a[href=\"#surface-diffusion-with-block-averages\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Surface diffusion with block averages<a class=\"headerlink\" href=\"#surface-diffusion-with-block-averages\" title=\"Link to this heading\">\u00b6</a></h2><p>This section repeats the same example,\nbut now with block averages of velocities.\n<a class=\"reference internal\" href=\"../preparing_inputs/block_averages.html\"><span class=\"std std-doc\">Block averages</span></a>\nare primarily useful for reducing storage requirements\nwhen saving trajectories to disk before processing them with STACIE.\nIn this example, the block size is determined by the following guideline:</p>", "a[href=\"#potential-energy-surface\"]": "<h3 class=\"tippy-header\" style=\"margin-top: 0;\">Potential energy surface<a class=\"headerlink\" href=\"#potential-energy-surface\" title=\"Link to this heading\">\u00b6</a></h3><p>The first cell below defines the potential energy of a particle on a surface,\nas well as the force that the surface exerts on the particle.\nThe potential energy model is a superposition of cosine functions:</p>", "a[href=\"../preparing_inputs/block_averages.html\"]": "<h1 class=\"tippy-header\" style=\"margin-top: 0;\">Reducing Storage Requirements with Block Averages<a class=\"headerlink\" href=\"#reducing-storage-requirements-with-block-averages\" title=\"Link to this heading\">\u00b6</a></h1><p>When computer simulations generate time-dependent data,\nthey often use a discretization of the time axis with a resolution (much) higher\nthan needed for computing the autocorrelation integral with STACIE.\nStoring (and processing) all these data may require excessive resources.\nTo reduce the amount of data, we recommend taking block averages.\nThese block averages form a new time series with a time step equal to the block size\nmultiplied by the original time step.\nThey reduce storage requirements by a factor equal to the block size.\nIf the program generating the sequences does not support block averages,\nyou can use <a class=\"reference internal\" href=\"../apidocs/stacie.utils.html#stacie.utils.block_average\" title=\"stacie.utils.block_average\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">stacie.utils.block_average()</span></code></a>.</p><p>If the blocks are sufficiently small compared to the decay rate of the autocorrelation function,\nSTACIE will produce virtually the same results.\nThe effect of block averages can be understood by inserting them into the discrete power spectrum,\nusing STACIE\u2019s normalization convention to obtain the proper zero-frequency limit.\nLet <span class=\"math notranslate nohighlight\">\\(\\hat{a}_\\ell\\)</span> be the <span class=\"math notranslate nohighlight\">\\(\\ell\\)</span>\u2019th block average of <span class=\"math notranslate nohighlight\">\\(L\\)</span> blocks with block size <span class=\"math notranslate nohighlight\">\\(B\\)</span>.\nWe can start from the power spectrum of the original sequence, <span class=\"math notranslate nohighlight\">\\(\\hat{x}_n\\)</span>,\nand then introduce approximations to rewrite it in terms of the block averages:</p>"}
skip_classes = ["headerlink", "sd-stretched-link"]

window.onload = function () {
    for (const [select, tip_html] of Object.entries(selector_to_html)) {
        const links = document.querySelectorAll(` ${select}`);
        for (const link of links) {
            if (skip_classes.some(c => link.classList.contains(c))) {
                continue;
            }

            tippy(link, {
                content: tip_html,
                allowHTML: true,
                arrow: true,
                placement: 'auto-start', maxWidth: 500, interactive: false,

            });
        };
    };
    console.log("tippy tips loaded!");
};
